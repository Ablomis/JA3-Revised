-- ========== GENERATED BY CombatAction Editor DO NOT EDIT MANUALLY! ==========

PlaceObj('CombatAction', {
	ActionCamera = true,
	ActionPoints = 3000,
	ActionType = "Ranged Attack",
	ConfigurableKeybind = false,
	CostBasedOnWeapon = true,
	dmg_penalty = 0,
	num_shots = 15,
	cth_loss_per_shot=1,
	Description = "Make a burst attack<coneDescription>. Lower accuracy against distant enemies, and further reduced accuracy if fired without being Set.<interrupts_info>",
	DisplayName = "Long Burst",
	Execute = function (self, units, args)
		local unit = units[1]
		local weapon = self:GetAttackWeapons(unit, args)
		args.num_shots = self.num_shots
		args.multishot = true
		local ap = self:GetAPCost(unit, args)
		NetStartCombatAction(self.id, unit, ap, args)
	end,
	GetAPCost = function (self, unit, args)
		local weapon = self:GetAttackWeapons(unit, args)
		if not weapon then return -1 end
		local ap = unit:GetAttackAPCost(self, weapon, nil, args and args.aim or 0)
		if( args~= nil and unit:GetLastAttack()==args.target) then return ap end
		local readyAP = weapon.ReadyAP
		local apReduction = GetComponentEffectValue(weapon, "FasterWeaponReady", "ready_ap")
		if(apReduction) then readyAP=Max(0, readyAP-apReduction) end
		return ap+readyAP
	end,
	GetActionDamage = function (self, unit, target, args)
		local weapon = args and args.weapon or self:GetAttackWeapons(unit, args)
		if not weapon then return 0 end
		local base = unit and unit:GetBaseDamage(weapon) or weapon.Damage
		local penalty = self.dmg_penalty
		local num_shots = self.num_shots
		base = MulDivRound(base, Max(0, 100 + penalty), 100)
		local damage = num_shots*base
		return damage, base, damage - base
	end,
	GetActionDescription = function (self, units)
		local description = self.Description
		if (description or "") == "" then
			description = self:GetActionDisplayName()
		end
		
		local unit = units[1]
		local coneDescription = T{""}
		local interrupts_info = ""
		local overwatch = g_Overwatch[unit]
		if overwatch and overwatch.permanent then
			coneDescription = T(480046777812, " within the set cone")
			interrupts_info = T{757307734445, "<newline><newline>Interrupt attacks: <interrupts>", interrupts = unit:GetNumMGInterruptAttacks()}
		end
		
		return T{description, coneDescription = coneDescription, interrupts_info = interrupts_info}
	end,
	GetActionDisplayName = function (self, units)
		local name = self.DisplayName
		if (name or "") == "" then
			name = Untranslated(self.id)
		end
		local unit = units[1]
		return CombatActionsAppendFreeAimActionName(self, unit, name)
	end,
	GetActionIcon = function (self, units)
		-- replace icon when using Revolver
		local unit = units and units[1]
		if unit then
			local weapon = self:GetAttackWeapons(unit)
			if IsKindOf(weapon, "Revolver") then
				return CombatActions.Fanning.Icon
			end
		end
		return self.Icon
	end,
	GetActionResults = function (self, unit, args)
		local args = table.copy(args)
		args.weapon = args.weapon or self:GetAttackWeapons(unit, args)
		args.num_shots = self.num_shots
		args.multishot = true
		args.damage_bonus = self.dmg_penalty
		args.cth_loss_per_shot = args.weapon.Recoil
		local attack_args = unit:PrepareAttackArgs(self.id, args)
		local results = attack_args.weapon:GetAttackResults(self, attack_args)
		return results, attack_args
	end,
	GetAnyTarget = function (self, units)
		return CombatActionGetOneAttackableEnemy(self, units and units[1], nil, CombatActionTargetFilters.MGBurstFire, units)
	end,
	GetAttackWeapons = function (self, unit, args)
		if args and args.weapon then return args.weapon end
		return unit:GetActiveWeapons("Firearm")
	end,
	GetTargets = function (self, units)
		return CombatActionGetAttackableEnemies(self, units and units[1], nil, CombatActionTargetFilters.MGBurstFire, units)
	end,
	GetUIState = function (self, units, args)
		return CombatActionGenericAttackGetUIState(self, units, args)
	end,
	Icon = "UI/Icons/Hud/burst_fire",
	IsTargetableAttack = true,
	KeybindingFromAction = "actionRedirectHeavyAttack",
	KeybindingSortId = "2372",
	MultiSelectBehavior = "first",
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "num_shots",
			'Value', 8,
			'Tag', "<num_shots>",
		}),
		PlaceObj('PresetParamPercent', {
			'Name', "cth_loss_per_shot",
			'Tag', "<cth_loss_per_shot>%",
		}),
		PlaceObj('PresetParamPercent', {
			'Name', "dmg_penalty",
			'Value', -50,
			'Tag', "<dmg_penalty>%",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "min_shots",
			'Value', 1,
			'Tag', "<min_shots>",
		}),
	},
	RequireState = "any",
	RequireWeapon = true,
	Run = function (self, unit, ap, ...)
		unit:SetActionCommand("FirearmAttack", self.id, ap, ...)
	end,
	UIBegin = function (self, units, args)
		CombatActionAttackStart(self, units, args, "IModeCombatAttack")
	end,
	group = "WeaponAttacks",
	id = "MGBurstFire",
})


PlaceObj('CombatAction', {
	ActionCamera = true,
	ActionPointDelta = -1000,
	ActionType = "Ranged Attack",
	AimType = "line",
	Comment = "-> Attack FiringMode",
	ConfigurableKeybind = false,
	CostBasedOnWeapon = true,
	FiringModeMember = "Attack",
	Description = T(775000951525, --[[CombatAction SingleShot Description]] "Cheap attack that conserves ammo."),
	DisplayName = T(776288626327, --[[CombatAction SingleShot DisplayName]] "Single Shot"),
	DisplayNameShort = T(641608509701, --[[CombatAction SingleShot DisplayNameShort]] "Single"),
	GetAPCost = function (self, unit, args)
		local weapon1, weapon2 = self:GetAttackWeapons(unit, args)
		if unit:OutOfAmmo(weapon2) or unit:IsWeaponJammed(weapon2) then
			weapon2 = nil
		end
		if weapon1 and weapon2 then
			return -1
		end
		if not weapon1 then return -1 end
		local ap = unit:GetAttackAPCost(self, weapon1, false, args and args.aim or 0, self.ActionPointDelta) or -1
		if( args~= nil and unit:GetLastAttack()==args.target) then return ap end
		local readyAP = weapon1.ReadyAP
		local apReduction = GetComponentEffectValue(weapon1, "FasterWeaponReady", "ready_ap")
		if(apReduction) then readyAP=Max(0, readyAP-apReduction) end
		return ap+readyAP
	end,
	GetActionDamage = function (self, unit, target, args)
		return CombatActionsAttackGenericDamageCalculation(self, unit, args)
	end,
	GetActionDescription = function (self, units)
		local unit = units[1]
		local _, _, _, params = self:GetActionDamage(unit)
		local descr = T{self.Description, damage = GetDamageRangeText(params.min, params.max), crit = params.critChance}
		descr = CombatActionsAppendFreeAimDescription(self, unit, descr)
		return descr
	end,
	GetActionDisplayName = function (self, units)
		local name = self.DisplayName
		if (name or "") == "" then
			name = Untranslated(self.id)
		end
		local unit = units[1]
		return CombatActionsAppendFreeAimActionName(self, unit, name)
	end,
	GetActionResults = function (self, unit, args)
		local attack_args = unit:PrepareAttackArgs(self.id, args)
		local results = attack_args.weapon:GetAttackResults(self, attack_args)
		return results, attack_args
	end,
	GetAttackWeapons = function (self, unit, args)
		if args and args.weapon then return args.weapon end
		local weapon, _, list = unit:GetActiveWeapons("Firearm")
		return weapon
	end,
	GetUIState = function (self, units, args)
		local unit = units[1]
		local attackWep = self:GetAttackWeapons(unit, args)
		if not attackWep then return "hidden" end
		return CombatActionGenericAttackGetUIState(self, units, args)
	end,
	Icon = "UI/Icons/Hud/attack",
	IconFiringMode = "UI/Hud/fm_single_shot",
	IsTargetableAttack = true,
	KeybindingFromAction = "actionRedirectBasicAttack",
	MultiSelectBehavior = "first",
	RequireState = "any",
	RequireWeapon = true,
	Run = function (self, unit, ap, ...)
		unit:SetActionCommand("FirearmAttack", self.id, ap, ...)
	end,
	StealthAttack = true,
	UIBegin = function (self, units, args)
		CombatActionAttackStart(self, units, args, "IModeCombatAttack")
	end,
	basicAttack = true,
	group = "WeaponAttacks",
	id = "SingleShot",
})

PlaceObj('CombatAction', {
	ActionCamera = true,
	ActionPoints = 3000,
	ActionType = "Ranged Attack",
	Comment = "-> Attack FiringMode",
	ConfigurableKeybind = false,
	dmg_penalty = 0,
	num_shots = 3,
	cth_loss_per_shot=0,
	CostBasedOnWeapon = true,
	Description = T(407142474259, --[[CombatAction BurstFire Description]] "Shoots <em><num> bullets</em> at the target. Lower accuracy against distant enemies."),
	DisplayName = T(956399226505, --[[CombatAction BurstFire DisplayName]] "Burst Fire"),
	DisplayNameShort = T(434110622708, --[[CombatAction BurstFire DisplayNameShort]] "Burst"),
	Execute = function (self, units, args)
		local unit = units[1]
		local weapon = self:GetAttackWeapons(unit, args)
		args.num_shots = self.num_shots
		args.multishot = true
		local ap = self:GetAPCost(unit, args)
		NetStartCombatAction(self.id, unit, ap, args)
	end,
	FiringModeMember = "Attack",
	GetAPCost = function (self, unit, args)
		if self.CostBasedOnWeapon then
			local weapon = self:GetAttackWeapons(unit, args)	
			local ap = weapon and (unit:GetAttackAPCost(self, weapon, nil, args and args.aim or 0) + self.ActionPointDelta) or -1
			if( args~= nil and unit:GetLastAttack()==args.target) then return ap end
			local readyAP = weapon.ReadyAP
			local apReduction = GetComponentEffectValue(weapon, "FasterWeaponReady", "ready_ap")
			if(apReduction) then readyAP=Max(0, readyAP-apReduction) end
			return ap+readyAP
		end
		return self.ActionPoints
	end,
	GetActionDamage = function (self, unit, target, args)
		local weapon = self:GetAttackWeapons(unit, args)
		if not weapon then return 0 end
		local base = unit and unit:GetBaseDamage(weapon) or weapon.Damage
		local penalty = self.dmg_penalty
		local num_shots = self.num_shots
		base = MulDivRound(base, Max(0, 100 + penalty), 100)
		local damage = num_shots*base
		return damage, base, damage - base
	end,
	GetActionDescription = function (self, units)
		local description = self.Description
		local unit = units and units[1]
		if not unit then
			return self:GetActionDisplayName()
		end
		local weapon = self:GetAttackWeapons(unit)
		
		-- replace description when using Revolver
		if IsKindOf(weapon, "Revolver") then
			description = CombatActions.Fanning.Description
		end
		
		local damage, base, bonus = self:GetActionDamage(unit)
		local num_shots = self.num_shots
		local descr = T{description, num = num_shots, damage = base}
		return CombatActionsAppendFreeAimDescription(self, unit, descr)
	end,
	GetActionDisplayName = function (self, units)
		local name = self.DisplayName
		
		-- replace name when using Revolver
		local unit = units and units[1]
		if unit then
			local weapon = self:GetAttackWeapons(unit)
			if IsKindOf(weapon, "Revolver") then
				name = CombatActions.Fanning.DisplayName
			end
		end
		
		if (name or "") == "" then
			name = Untranslated(self.id)
		end
		return CombatActionsAppendFreeAimActionName(self, unit, name)
	end,
	GetActionIcon = function (self, units)
		-- replace icon when using Revolver
		local unit = units and units[1]
		if unit then
			local weapon = self:GetAttackWeapons(unit)
			if IsKindOf(weapon, "Revolver") then
				return CombatActions.Fanning.Icon
			end
		end
		return self.Icon
	end,
	GetActionResults = function (self, unit, args)
		local args = table.copy(args)
		args.weapon = self:GetAttackWeapons(unit, args)
		args.num_shots = self.num_shots
		args.multishot = true
		args.damage_bonus = self.dmg_penalty
		args.cth_loss_per_shot = args.weapon.Recoil
		local attack_args = unit:PrepareAttackArgs(self.id, args)
		local results = attack_args.weapon:GetAttackResults(self, attack_args)
		return results, attack_args
	end,
	GetAttackWeapons = function (self, unit, args)
		if args and args.weapon then return args.weapon end
		local weapon, _, list = unit:GetActiveWeapons("Firearm")
		return weapon
	end,
	GetUIState = function (self, units, args)
		local unit = units[1]
		local weapon = self:GetAttackWeapons(unit, args)
		local num_shots = self.num_shots
		if not weapon.ammo or weapon.ammo.Amount < num_shots then
			return "disabled", AttackDisableReasons.InsufficientAmmo
		end
		
		return CombatActionGenericAttackGetUIState(self, units, args)
	end,
	Icon = "UI/Icons/Hud/burst_fire",
	IconFiringMode = "UI/Hud/fm_burst_fire",
	IsTargetableAttack = true,
	MultiSelectBehavior = "first",
	Parameters = {
		PlaceObj('PresetParamNumber', {
			'Name', "num_shots",
			'Value', 3,
			'Tag', "<num_shots>",
		}),
		PlaceObj('PresetParamPercent', {
			'Name', "cth_loss_per_shot",
			'Tag', "<cth_loss_per_shot>%",
		}),
		PlaceObj('PresetParamPercent', {
			'Name', "dmg_penalty",
			'Value', 0,
			'Tag', "<dmg_penalty>%",
		}),
	},
	RequireState = "any",
	RequireWeapon = true,
	Run = function (self, unit, ap, ...)
		unit:SetActionCommand("FirearmAttack", self.id, ap, ...)
	end,
	SortKey = 2,
	StealthAttack = true,
	UIBegin = function (self, units, args)
		CombatActionAttackStart(self, units, args, "IModeCombatAttack")
	end,
	basicAttack = true,
	group = "WeaponAttacks",
	id = "BurstFire",
})

PlaceObj('CombatAction', {
	ActionPoints = 10000,
	ActionType = "Ranged Attack",
	AimType = "line",
	Comment = "-> Attack FiringMode",
	ConfigurableKeybind = false,
	dmg_penalty = 0,
	num_shots = 15,
	cth_loss_per_shot=0,
	Description = T(631854101896, --[[CombatAction AutoFire Description]] "<em>Spends all AP</em>.\nShoots a hail of <em><bullets> bullets</em> and inflict <GameTerm('Suppressed')> even on miss when the enemy is in weapon range. Lower accuracy against distant enemies."),
	DisplayName = T(729612747243, --[[CombatAction AutoFire DisplayName]] "Auto Fire"),
	DisplayNameShort = T(845536748856, --[[CombatAction AutoFire DisplayNameShort]] "Auto"),
	Execute = function (self, units, args)
		local unit = units[1]
		args.multishot = true
		local weapon = self:GetAttackWeapons(unit, args)
		args.num_shots = self.num_shots
		local ap = self:GetAPCost(unit, args)
		NetStartCombatAction(self.id, unit, ap, args)
	end,
	FiringModeMember = "Attack",
	GetAPCost = function (self, unit, args)
		local weapon = self:GetAttackWeapons(unit, args)
		if not weapon or not weapon:CanAutofire() then
			return -1
		end
		return unit:GetMaxActionPoints()
	end,
	GetActionDamage = function (self, unit, target, args)
		local weapon = self:GetAttackWeapons(unit, args)
		if not weapon then return 0 end
		local base = unit:GetBaseDamage(weapon)
		local penalty = self.dmg_penalty
		local num_shots = self.num_shots
		base = MulDivRound(base, Max(0, 100 + penalty), 100)
		local damage = num_shots*base
		return damage, base, damage - base
	end,
	GetActionDescription = function (self, units)
		local unit = units[1]
		local weapon = self:GetAttackWeapons(unit)
		local damage, base, bonus = self:GetActionDamage(unit)
		local params = weapon:GetAreaAttackParams("AutoFire")
		local descr = T{self.Description, damage = base, bullets = weapon:GetAutofireShots(self)}
		return CombatActionsAppendFreeAimDescription(self, unit, descr)
	end,
	GetActionDisplayName = function (self, units)
		local name = self.DisplayName
		if (name or "") == "" then
			name = Untranslated(self.id)
		end
		local unit = units[1]
		return CombatActionsAppendFreeAimActionName(self, unit, name)
	end,
	GetActionResults = function (self, unit, args)
		local args = table.copy(args)
		args.applied_status = "Suppressed"
		args.multishot = true
		args.weapon = self:GetAttackWeapons(unit, args)
		args.num_shots = self.num_shots
		--args.single_fx = true
		--args.fx_action = "WeaponAutoFire"
		args.damage_bonus = self.dmg_penalty
		args.cth_loss_per_shot = args.weapon.Recoil
		local attack_args = unit:PrepareAttackArgs(self.id, args)
		local results = attack_args.weapon:GetAttackResults(self, attack_args)
		local target = attack_args.target			
		if results.miss and not attack_args.stuck and IsKindOf(target, "Unit") and IsValidTarget(target) then
			local target_dist = unit:GetDist(target)
			local weapon = attack_args.weapon
			if target_dist <= weapon.WeaponRange * const.SlabSizeX then
				local flight_dist = 0
				for _, shot in ipairs(results.shots) do
					for _, hit in ipairs(shot.hits) do
						flight_dist = Max(flight_dist, shot.attack_pos:Dist(hit.pos))
					end	
				end
				flight_dist = flight_dist / const.SlabSizeX
				target_dist = target_dist / const.SlabSizeX
				if flight_dist >= target_dist - 1 then
					results.extra_packets = results.extra_packets or {}
					table.insert(results.extra_packets, {target = target, effects = "Suppressed"})
				end
			end
		end
		return results, attack_args
	end,
	GetAttackWeapons = function (self, unit, args)
		if args and args.weapon then return args.weapon end
		local weapon, _, list = unit:GetActiveWeapons("Firearm")
		return weapon
	end,
	GetUIState = function (self, units, args)
		local state, err = CombatActionGenericAttackGetUIState(self, units, args)
		if state ~= "enabled" then return state, err end
		
		local unit = units[1]
		local weapon = self:GetAttackWeapons(unit, args)
		local autoFire_ammo = weapon:GetAutofireShots(self)
		if not weapon.ammo or weapon.ammo.Amount < autoFire_ammo then
			return "disabled", AttackDisableReasons.InsufficientAmmo
		end
		return "enabled"
	end,
	Icon = "UI/Icons/Hud/full_auto",
	IconFiringMode = "UI/Hud/fm_autoshot",
	IsAimableAttack = false,
	IsTargetableAttack = true,
	MultiSelectBehavior = "first",
	Parameters = {
		PlaceObj('PresetParamPercent', {
			'Name', "cth_loss_per_shot",
			'Tag', "<cth_loss_per_shot>%",
		}),
		PlaceObj('PresetParamPercent', {
			'Name', "dmg_penalty",
			'Value', 0,
			'Tag', "<dmg_penalty>%",
		}),
		PlaceObj('PresetParamNumber', {
			'Name', "num_shots",
			'Value', 15,
			'Tag', "<num_shots>",
		}),
	},
	RequireState = "any",
	RequireWeapon = true,
	Run = function (self, unit, ap, ...)
		unit:SetActionCommand("FirearmAttack", self.id, ap, ...)
	end,
	SortKey = 3,
	UIBegin = function (self, units, args)
		CombatActionAttackStart(self, units, args, "IModeCombatAttack")
	end,
	basicAttack = true,
	group = "WeaponAttacks",
	id = "AutoFire",
})

PlaceObj('CombatAction', {
	ActionType = "Ranged Attack",
	AimType = "cone",
	ConfigurableKeybind = false,
	min_cost=4,
	max_cost=8,
	min_dex=50,
	Description = "Focus on a cone-shaped area, immobilizing yourself and going <em>prone</em>. You can only shoot enemies inside that cone. Accuracy is increased and enemies will provoke <em>interrupt</em> attacks with actions inside the cone (even if your AP are spent).",
	DisplayName = "Set Sniper Rifle",
	Execute = function (self, units, args)
		local unit = units[1]
		local ap = self:GetAPCost(unit, args)
		args.aim_ap = unit:GetUIActionPoints() - ap
		NetStartCombatAction(self.id, unit, ap, args)
	end,
	GetAPCost = function (self, unit, args)
		local base = self.max_cost * const.Scale.AP
		local min = self.min_cost * const.Scale.AP
		local min_dex = self.min_dex
		local cost = base - MulDivRound(Max(0, unit.Dexterity - min_dex), base - min, 100 - min_dex)
		cost = Max(min, (cost / const.Scale.AP) * const.Scale.AP)
		return cost
	end,
	GetActionDescription = function (self, units)
		local unit = units[1]
		local bonus = 0
		local cost = self:GetAPCost(unit)
		if unit and cost >= 0 then
			local weapon = self:GetAttackWeapons(unit)
			if not weapon then return self.Description end
			local aim = Min((unit:GetUIActionPoints() - cost) / const.Scale.AP, weapon.MaxAimActions)
			local apply, value = Presets.ChanceToHitModifier.Default.Aim:CalcValue(unit, nil, nil, nil, nil, nil, nil, aim)
			bonus = value
		end
		
		local attacks = 1
		if unit and (cost or -1) >= 0 then
			--attacks = unit:GetNumMGInterruptAttacks(true)
			attacks = 1
		end
		local description = T{self.Description, bonus = bonus}
		
		if unit:UIHasAP(cost, self.id) then
			description = description .. T{813594976169, "<newline><newline>Max interrupt attacks: <attacks>", attacks = attacks}
		end
		
		return description
	end,
	GetActionResults = function (self, unit, args)
		return CombatActions.Overwatch.GetActionResults(self, unit, args)
	end,
	GetAimParams = function (self, unit, weapon)
		return CombatActions.Overwatch.GetAimParams(self, unit, weapon)
	end,
	GetAttackWeapons = function (self, unit, args)
		if args and args.weapon then return args.weapon end
		return unit:GetActiveWeapons("Firearm")
	end,
	GetMaxAimRange = function (self, unit, weapon)
		return CombatActions.Overwatch.GetMaxAimRange(self, unit, weapon)
	end,
	GetMinAimRange = function (self, unit, weapon)
		return CombatActions.Overwatch.GetMinAimRange(self, unit, weapon)
	end,
	GetUIState = function (self, units, args)
		local unit = units[1]
		local cost = self:GetAPCost(unit, args)
		if cost < 0 then return "hidden" end
		local weapon = self:GetAttackWeapons(unit, args)
		local ok, reason = unit:CanUseWeapon(weapon)
		if not ok then return "disabled", reason end
		if not unit:UIHasAP(cost) then return "disabled", GetUnitNoApReason(unit) end
		local in_water = terrain.IsWater(unit)
		if in_water then 
			return "disabled", AttackDisableReasons.Water 
		end
		local attack = unit:GetDefaultAttackAction()
		local state, reason = attack:GetUIState(units, args)
		if state ~= "enabled" and (reason == AttackDisableReasons.NoWeapon or reason == AttackDisableReasons.OutOfAmmo or reason == AttackDisableReasons.WeaponJammed or reason == AttackDisableReasons.InsufficientAmmo) then
			return state, reason
		end
		return "enabled"
	end,
	Parameters = {},
	Icon = "UI/Icons/Hud/SetMachineGun ",
	KeybindingFromAction = "actionRedirectOverwatch",
	KeybindingSortId = "2370",
	RequireState = "any",
	Run = function (self, unit, ap, ...)
		unit:SetActionCommand("SniperSetup", self.id, ap, ...)
	end,
	UIBegin = function (self, units, args)
		CombatActionAttackStart(self, units, args, "IModeCombatAreaAim", "cancel")
	end,
	group = "SniperRifle",
	id = "SniperSetup"
})

PlaceObj('CombatAction', {
	ActionPoints = 1000,
	Description = "Cancel sniper setup and move freely.",
	DisplayName = "Pack Up Sniper Rifle",
	Execute = function (self, units, args)
		local unit = units[1]
		local ap = self:GetAPCost(unit, args)
		NetStartCombatAction(self.id, unit, ap, args)
	end,
	GetAPCost = function (self, unit, args)		
		return self.ActionPoints
	end,
	Icon = "UI/Icons/Hud/dash",
	KeybindingSortId = "2375",
	RequireState = "any",
	Run = function (self, unit, ap, ...)
		unit:SetActionCommand("SniperPack", self.id, ap, ...)
	end,
	UIBegin = function (self, units, args)
		self:Execute(units, args)
	end,
	group = "SniperRifle",
	id = "SniperPack",
	param_bindings = {},
})

PlaceObj('CombatAction', {
	ActionPoints = 5000,
	ActionType = "Ranged Attack",
	AimType = "cone",
	ConfigurableKeybind = false,
	Description ="Rotate the sniper rifle's firing cone.",
	DisplayName = "Rotate Sniper Rifle",
	Execute = function (self, units, args)
		local unit = units[1]
		local ap = self:GetAPCost(unit, args)
		args.aim_ap = unit:GetUIActionPoints() - ap
		NetStartCombatAction(self.id, unit, ap, args)
	end,
	GetAPCost = function (self, unit, args)
		local cost = CombatActions.SniperSetup:GetAPCost(unit, args) / 2
		cost = Max(1, cost / const.Scale.AP) * const.Scale.AP
		return cost
	end,
	GetActionDescription = function (self, units)
		local unit = units[1]
		local bonus = 0
		local cost = self:GetAPCost(unit)
		
		if unit and cost >= 0 then
			local weapon = self:GetAttackWeapons(unit)
			local aim = Min((unit:GetUIActionPoints() - cost) / const.Scale.AP, weapon.MaxAimActions)
			local apply, value = Presets.ChanceToHitModifier.Default.Aim:CalcValue(unit, nil, nil, nil, nil, nil, nil, aim)
			bonus = value
		end
		
		local attacks = 1
		if unit and (cost or -1) >= 0 then
			attacks = 1
		end
		local description = T{self.Description, bonus = bonus}
		if unit:UIHasAP(cost, self.id) then
			description = description .. T{813594976169, "<newline><newline>Max interrupt attacks: <attacks>", attacks = attacks}
		end
		
		return description
	end,
	GetActionResults = function (self, unit, args)
		return CombatActions.Overwatch.GetActionResults(self, unit, args)
	end,
	GetAimParams = function (self, unit, weapon)
		return CombatActions.Overwatch.GetAimParams(self, unit, weapon)
	end,
	GetAttackWeapons = function (self, unit, args)
		if args and args.weapon then return args.weapon end
		return unit:GetActiveWeapons("Firearm")
	end,
	GetMaxAimRange = function (self, unit, weapon)
		return CombatActions.Overwatch.GetMaxAimRange(self, unit, weapon)
	end,
	GetMinAimRange = function (self, unit, weapon)
		return CombatActions.Overwatch.GetMinAimRange(self, unit, weapon)
	end,
	GetUIState = function (self, units, args)
		local unit = units[1]
		local cost = self:GetAPCost(unit, args)
		if cost < 0 then return "hidden" end
		if not unit:UIHasAP(cost) then return "disabled", GetUnitNoApReason(unit) end
		local in_water = terrain.IsWater(unit)
		if in_water then 
			return "disabled", AttackDisableReasons.Water 
		end
		return "enabled"
	end,
	Icon = "UI/Icons/Hud/bullet_hell",
	IsAimableAttack = false,
	MultiSelectBehavior = "hidden",
	Run = function (self, unit, ap, ...)
		--PlayVoiceResponse(unit, "Overwatch")
		unit:SetActionCommand("SniperTarget", self.id, ap, ...)
	end,
	UIBegin = function (self, units, args)
		CombatActionAttackStart(self, units, args, "IModeCombatAreaAim", "cancel")
	end,
	group = "SniperRifle",
	id = "SniperRotate",
})

PlaceObj('CombatAction', {
	ActionType = "Ranged Attack",
	AimType = "cone",
	Comment = "-> ShotgunAttack FiringMode",
	ConfigurableKeybind = false,
	CostBasedOnWeapon = true,
	Description = T(734174652599, --[[CombatAction Buckshot Description]] "All enemy targets in cover are <GameTerm('Exposed')>.\nInflicts additional status effects based on the ammo. All targets affected by the area of attack receive additional damage."),
	DisplayName = T(673459341122, --[[CombatAction Buckshot DisplayName]] "Shotgun Shot"),
	DisplayNameShort = T(686623207963, --[[CombatAction Buckshot DisplayNameShort]] "Single"),
	FiringModeMember = "AttackShotgun",
	GetAPCost = function (self, unit, args)
		local weapon1, weapon2 = self:GetAttackWeapons(unit, args)
		if weapon1 and weapon2 then
			return -1
		end
		if not weapon1 then return -1 end 
		local ap = unit:GetAttackAPCost(self, weapon1, false, args and args.aim or 0) or -1

		if( args~= nil and unit:GetLastAttack()==args.target) then return ap end
		local readyAP = weapon1.ReadyAP
		local apReduction = GetComponentEffectValue(weapon1, "FasterWeaponReady", "ready_ap")
		if(apReduction) then readyAP=Max(0, readyAP-apReduction) end
		return ap+readyAP
	end,
	GetActionDamage = function (self, unit, target, args)
		local weapon = self:GetAttackWeapons(unit, args)
		local base = weapon and unit:GetBaseDamage(weapon) or 0
		local aoeDamage = MulDivRound(base, const.Weapons.ShotgunCollateralDamage, 100)
		
		return base, base, 0, { aoe_damage = aoeDamage }
	end,
	GetActionDescription = function (self, units)
		local unit = units[1]
		local damage, _, _, params = self:GetActionDamage(unit)
		local descr = T{self.Description, damage = damage, aoedamage = params.aoe_damage}
		descr = CombatActionsAppendFreeAimDescription(self, unit, descr)
		return descr
	end,
	GetActionDisplayName = function (self, units)
		local name = self.DisplayName
		if (name or "") == "" then
			name = Untranslated(self.id)
		end
		local unit = units[1]
		return CombatActionsAppendFreeAimActionName(self, unit, name)
	end,
	GetActionResults = function (self, unit, args)
		local args = table.copy(args)
		if not args.target_spot_group then
			args.num_shots = 0
		end
		args.aoe_action_id = self.id
		args.fx_action = "WeaponBuckshot"
		args.aoe_fx_action = "WeaponBuckshot"
		args.single_fx = true
		args.aoe_damage_type = "percent"
		args.aoe_damage_value = const.Weapons.ShotgunCollateralDamage
		args.buckshot_scatter_fx = 10
		local attack_args = unit:PrepareAttackArgs(self.id, args)
		local results = attack_args.weapon:GetAttackResults(self, attack_args)
		return results, attack_args
	end,
	GetAttackWeapons = function (self, unit, args)
		if args and args.weapon then return args.weapon end
		return unit:GetActiveWeapons("Firearm")
	end,
	GetMaxAimRange = function (self, unit, weapon)
		return weapon.WeaponRange
	end,
	GetMinAimRange = function (self, unit, weapon)
		return 2
	end,
	GetUIState = function (self, units, args)
		return CombatActionGenericAttackGetUIState(self, units, args)
	end,
	Icon = "UI/Icons/Hud/shotgun_shot",
	IconFiringMode = "UI/Hud/fm_buckshot",
	IsTargetableAttack = true,
	KeybindingFromAction = "actionRedirectBasicAttack",
	MultiSelectBehavior = "first",
	RequireState = "any",
	RequireWeapon = true,
	Run = function (self, unit, ap, ...)
		unit:SetActionCommand("FirearmAttack", self.id, ap, ...)
	end,
	SortKey = 1,
	StealthAttack = true,
	UIBegin = function (self, units, args)
		local dlg = GetInGameInterfaceModeDlg()
		if IsKindOf(dlg, "IModeCombatAreaAim") and dlg.crosshair then
			CombatActionAttackStart(self, units, args, "IModeCombatAreaAim", "attack")
		else
			CombatActionAttackStart(self, units, args, "IModeCombatAreaAim")
		end
	end,
	basicAttack = true,
	group = "WeaponAttacks",
	id = "Buckshot",
})

PlaceObj('CombatAction', {
	Description = T(646737101780, --[[CombatAction Reload Description]] "<em>Reload</em> or <em>change</em> ammo."),
	DisplayName = T(642187794904, --[[CombatAction Reload DisplayName]] "Reload"),
	GetAPCost = function (self, unit, args)
		if unit:HasStatusEffect("ManningEmplacement") then return -1 end
		local weapon
		if args and args.item_id then
			local alt_set = (unit.current_weapon == "Handheld A") and "Handheld B" or "Handheld A"
			weapon = FindWeaponInSlotById(unit, unit.current_weapon, args.item_id) or FindWeaponInSlotById(unit, alt_set, args.item_id) or FindWeaponInSlotById(unit, "Inventory", args.item_id)
		end
		
		if not weapon then
			if args and args.pos then
				weapon = unit:GetItemAtPackedPos(args.pos)			
			else
				weapon = unit:GetWeaponByDefIdOrDefault("Firearm", args and args.weapon)
			end
		end	
		return (weapon and not weapon.jammed) and GetReloadAP(weapon, args.item) or -1
	end,
	GetActionDisplayName = function (self, units)
		local unit = units[1]
		if not IsKindOf(unit, "Unit") then return end
		
		local w1, w2, weaponList = unit:GetActiveWeapons("Firearm")
		local canChange = false
		for i, w in ipairs(weaponList) do
			local ammoForWeapon = unit:GetAvailableAmmos(w, nil, "unique")
			local noAmmo = #ammoForWeapon == 0
			local onlyAmmoIsCurrent = w.ammo and #ammoForWeapon == 1 and ammoForWeapon[1].class == w.ammo.class
			local fullMag = not w.ammo or w.ammo.Amount == w.MagazineSize
			
			canChange = canChange or (onlyAmmoIsCurrent and fullMag)
		end
		
		if canChange then
			return T(817996274899, "Change Ammo")
		else
			return self.DisplayName
		end
	end,
	GetTargets = function (self, units)
		local unit = units[1]
		local weapon = unit:GetActiveWeapons()
		return unit:GetAvailableAmmos(weapon)
	end,
	GetUIState = function (self, units, args)
		if not g_Combat and #units ~= 1 then return "hidden" end
		
		local unit = units[1]
		local cost = self:GetAPCost(unit, args)
		if cost < 0 then return "hidden" end
		if not unit:UIHasAP(cost) then return "disabled", GetUnitNoApReason(unit) end
		local availableWeaponsToReload = 0
		
		local errorReason
		local weapon
		if args and args.pos then
			weapon = unit:GetItemAtPackedPos(args.pos)
		elseif args and args.weapon then
			weapon = unit:GetWeaponByDefIdOrDefault("Firearm", args and args.weapon, args and args.pos)
		end	
		if weapon then
			local weaponReloadOptions = GetReloadOptionsForWeapon(weapon, unit)
			if #weaponReloadOptions > 0 then
				availableWeaponsToReload = availableWeaponsToReload + 1
			end	
		else
			local w1, w2, weaponList = unit:GetActiveWeapons()
			if not weaponList then return "enabled" end
			for i, w in ipairs(weaponList) do
				local canReload, err = IsWeaponAvailableForReload(w, unit:GetAvailableAmmos(w, nil, "unique"))
				errorReason = err
				if canReload then
					availableWeaponsToReload = availableWeaponsToReload + 1
				end	
			end
		end	
		if availableWeaponsToReload == 0 then return "disabled", errorReason end	
		return "enabled"
	end,
	Icon = "UI/Icons/Hud/reload",
	IsAimableAttack = false,
	RequireState = "any",
	RequireWeapon = true,
	Run = function (self, unit, ap, ...)
		unit:SetActionCommand("ReloadAction", self.id, ap, ...)
	end,
	ShowIn = false,
	SortKey = 8,
	UIBegin = function (self, units, args)
		local unit = units[1]
		local mode_dlg = GetInGameInterfaceModeDlg()
		if IsKindOf(mode_dlg, "IModeCommonUnitControl") then
			-- Process weapons
			local w1, w2, weaponList = unit:GetActiveWeapons("Firearm")
			local processedList = {}
			for i, w in ipairs(weaponList) do
				local text = T{535301054415, "<weaponName>", weaponName = w.DisplayName}
				local ammoForWeapon = unit:GetAvailableAmmos(w, nil, "unique")
				local noAmmo = #ammoForWeapon == 0
				if w.ammo == 0 then
					text = text .. T(642941753004, " (Empty)")
				end
		
				local onlyAmmoIsCurrent = w.ammo and #ammoForWeapon == 1 and ammoForWeapon[1].class == w.ammo.class
				local fullMag = not w.ammo or w.ammo.Amount == w.MagazineSize
				
				local processedAmmo = {}
		
				for _, a in ipairs(ammoForWeapon) do
					local isCurrent = w.ammo and a.class == w.ammo.class
					local ammoEntry = {
						DisplayName = isCurrent and T{541680584484, "Current: <DisplayName>", a} or a.DisplayName,
						ammo = a,
						disabled = w.ammo and isCurrent and fullMag,
						icon = a.Icon,
						uiCtx = a,
						rolloverTemplate = "RolloverInventory"
					}
					if isCurrent then table.insert(processedAmmo, 1, ammoEntry) else table.insert(processedAmmo, ammoEntry) end
				end
				
				processedList[#processedList + 1] = { 
					DisplayName = text,
					weaponIdx = i,
					ammo = processedAmmo,
					disabled = noAmmo or (onlyAmmoIsCurrent and fullMag),
					icon = w.Icon,
					uiCtx = w,
					rolloverTemplate = "RolloverInventory"
				}
			end
			
			-- First you choose which weapon to reload, then you choose the ammo to load into it.
			local weaponChoiceCallback = function(u, weaponWrapped)
				local ammoChoiceCallback = function(u, ammoWrapped)
					self:Execute({u}, { weapon = weaponWrapped.weaponIdx, target = ammoWrapped.ammo.class })
				end
				mode_dlg:ShowCombatActionTargetChoice(self, {u}, weaponWrapped.ammo, ammoChoiceCallback, "suppress_toggle")
			end
		
			mode_dlg:ShowCombatActionTargetChoice(self, units, processedList, weaponChoiceCallback)
		else
			self:Execute(units)
		end
	end,
	group = "Hidden",
	id = "Reload",
})

PlaceObj('CombatAction', {
	ActionPoints = 6000,
	ActionShortcut = "U",
	Description = T(784247279587, --[[CombatAction ChangeWeapon Description]] "Swap to the alternative weapon set: <items>"),
	DisplayName = T(692166142490, --[[CombatAction ChangeWeapon DisplayName]] "Change Weapon"),
	GetAPCost = function (self, unit, args)
		if unit:CanActivatePerk("Scoundrel") then return 0 end
		local otherSet = "Handheld A"
		if unit and unit.current_weapon == "Handheld A" then
			otherSet = "Handheld B"
		end
		local weapons = unit:GetEquippedWeapons(otherSet)
		for _, weapon in ipairs(weapons) do
			if(IsKindOf(weapon, "Pistol")) then
				return RevisedConfigValues.PistolSwapAP
			end
			if weapon:HasComponent("FreeWeaponSwap") then
				return 0
			end
		end
		
		return self.ActionPoints
	end,
	GetActionDescription = function (self, units)
		local otherSetItems = GetUnitWeapons(units[1], "otherSet")
		local itemsConcat = {}
		for i, item in ipairs(otherSetItems) do
			itemsConcat[#itemsConcat + 1] = item.DisplayName
		end
		itemsConcat = table.concat(itemsConcat, ", ")
		
		return T{self.Description, items = itemsConcat}
	end,
	GetUIState = function (self, units, args)
		local unit = units[1]
		if not IsKindOf(unit, "Unit") then return "hidden" end
		if unit:GetBandageTarget() then
			return "disabled", AttackDisableReasons.BandagingDowned
		end
		if unit:HasStatusEffect("ManningEmplacement") or unit:HasStatusEffect("StationedMachineGun") then
			return "hidden", AttackDisableReasons.UsingMachineGun
		end
		if not unit:UIHasAP(self:GetAPCost(unit, args)) then return "disabled", AttackDisableReasons.NoAP end
		if g_Combat and HasCombatActionInProgress(unit) then return "hidden" end	
		
		return "enabled" -- always available to allow switching to unarmed attacks
	end,
	Icon = "UI/Icons/Hud/change_weapon_set",
	IsAimableAttack = false,
	KeybindingSortId = "2295",
	MultiSelectBehavior = "first",
	RequireState = "any",
	Run = function (self, unit, ap, ...)
		unit:SetActionCommand("SwapActiveWeapon", self.id, ap)
	end,
	ShowIn = "Special",
	SortKey = 11,
	group = "Hidden",
	id = "ChangeWeapon",
})

PlaceObj('CombatAction', {
	ActionPoints = 1000,
	DisplayName = T(796190228832, --[[CombatAction Move DisplayName]] "Move"),
	GetAPCost = function (self, unit, args)
		if not g_Combat then return 0 end
		if unit:HasStatusEffect("StationedMachineGun") or unit:HasStatusEffect("ManningEmplacement") or unit:HasStatusEffect("StationedSniper") then return -1 end
		local stance = args and args.stance
		local pos = args and args.goto_pos
		if not pos then return -1 end
		
		local startStance = args and args.stanceAtStart
		local endStance = args and args.stanceAtEnd
		local move_ap = args and args.available_move_ap or unit.ActionPoints
		local combatPath = GetCombatPath(unit, startStance or stance, move_ap, endStance or stance)
		local apCost = combatPath:GetAP(pos)
		if not apCost or apCost == -1 then return -1 end
		return apCost
	end,
	GetTargets = function (self, units)
		return units[1]:GetVisibleEnemies()
	end,
	GetUIState = function (self, units, args)
		local unit = units[1]
		if args then
			local cost = self:GetAPCost(unit, args)
			if cost < 0 then return "hidden" end
			if not unit:UIHasAP(cost, self.id) then return "disabled" end
		end
		if g_Combat and (unit:HasStatusEffect("StationedMachineGun") or unit:HasStatusEffect("ManningEmplacement") or unit:HasStatusEffect("StationedSniper") or unit:HasPreparedAttack()) then
			return "hidden"
		end
		if unit:GetBandageTarget() or unit:IsBeingBandaged() then
			return "hidden"
		end
		return "enabled"
	end,
	Icon = "UI/Icons/Hud/placeholder",
	InterruptInExploration = true,
	IsAimableAttack = false,
	MultiSelectBehavior = "hidden",
	RequireState = "any",
	Run = function (self, unit, ap, ...)
		local args = ...
		if g_Combat then
			unit:SetActionCommand("CombatGoto", self.id, ap, args.goto_pos, args.path, args.forced_run, args.stanceAtStart, args.stanceAtEnd, args.willBeTracked, args.visibleMovement)
		else
			if unit:IsInterruptable() then
				unit:InterruptCommand("GotoSlab", args.goto_pos, nil, nil, nil, args.follow_target)
			else
				unit:QueueCommand("GotoSlab", args.goto_pos, nil, nil, nil, args.follow_target)
			end
		end
	end,
	ShowIn = false,
	SimultaneousPlay = true,
	UseFreeMove = true,
	group = "Default",
	id = "Move",
})


